#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`



## 解析

* 动态规划：

  **思路：**找出不同的状态，并实现状态之间的转移

  f [x] [y] [z] 表示至x天为止最大利润，已经完成y[0,2]次交易，z[0,1] 1表示此时持有，0表示未持有。

  因此我们可以列出五种不同的**状态转移方程**

  ```c++
  f[x][0][1]=max(f[x-1][0][1],f[x-1][0][0]-prices[x])
  f[x][0][0]=0 //未操作都是0
  f[x][1][0]=max(f[x-1][1][0],f[x-1][0][1]+prices[x])
  f[x][1][1]=max(f[x-1][1][1],f[x-1][1][0]-prices[x])
  f[x][2][0]=max(f[x-1][2][0],f[x-1][1][1]+prices[x])
  ```

  接下来确定状态转移方程的**边界情况**

  ```c++
  f[0][0][1]=f[0][1][1]=-prices[0];//前者理解成第一天买入  后者理解为买入—卖出-买入
  f[0][0][0]=0; //未操作都是0
  f[0][1][0]=f[0][2][0]=0;//理解成卖出再买入
  ```

  * 优化：

  由于每一次转移都是**线性递增**，只和**上一天**的情况有关，所以我们利用变量存储数据即可。

  变量命名规则：`fx01=f[x][0][1]`

  * 注意：变量要是上一天的，但是我们在计算之中，上一天的变量会被这一天新改动的变量替代，因此要用**临时变量**存储上一天的情况。

  接下来确定最终情况

  答案一定是`max(0,fx10,fx20)`之中，但是`fx10 fx20 `在第一天就等价于当天买入卖出，因此我们只要找`max(fx10,fx20)`  再观察`f(x10)->f(x20)`  `f(x20)!->f(x10)`，前者状态可以无条件转移到后面（只要当天买入再卖出），后者不可以，假设当`fx10`是最大值，也会因为可以同一天买卖从`fx10`转移到`fx20`，所以有`fx20>=fx10>=0`，因此最大值取`fx20`即可

  AC代码：

  ```
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          int fx00=0,fx01=-prices[0],fx10=0,fx11=-prices[0],fx20=0;//边界一定要真实的情况，不然后面转移会出现问题
          for(int x=1;x<prices.size();x++)
          {
              int tx01=fx01,tx10=fx10,tx11=fx11,tx20=fx20;
              fx01=max(fx01,0-prices[x]);
              fx10=max(fx10,tx01+prices[x]);
              fx11=max(fx11,tx10-prices[x]);
              fx20=max(fx20,tx11+prices[x]);
          }
          //最后的时候
          return fx20;
      }
  };
  ```

  

  