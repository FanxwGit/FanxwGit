# F：对答案一时爽

​	贪心算法，最大的是A全对，B如果某个选项和A一样的的话，那么就对

# B：括号

​	由于构造长度的限制，我们要找到一个增加对数很高的一种方法，((((     ))))  ，中心对称法，效率很高，10e9 我们也只需要构造出10e3对即可，当数字并非平方数的时候，需要补上一些"**零头**"，答案=中心对称的括号对+零头

​	那么如何处理零头是最高效的呢？在已经形成中t对新对称的括号中，在右边或者左边增加一个相同方向的括号，都能增加t个，那么我们可以在一边增加：**(k-t\*t)/t** 个同方向的括号，然后在另外一边的第**delta=(k-t\*t)%t**个增加一个反方向的括号即可。



打个比方：当K=14的时候，首先构造出((())) ，然后在右边增加(14-3*3)/3个右括号，然后在左边第(14-3\*3)%3 个增加一个右括号，最后是(()())))

```
	cin>>k;
    if(k==0){cout<<")(";return 0;}
    int t=sqrt(k);
    int d=k-t*t;
     
    int time=d/t;
    int left=d%t;
    string ans="";
    for(int i=1;i<=t;i++){
        ans+='(';
        if(i==left){
            ans+=')';
        }
    }
    for(int i=1;i<=t+time;i++){
        ans+=')';
    }
    cout<<ans;
```



# I: 限制不互为素数对的排列

​	首先观察k的取值范围，k<=n/2 ，那么我们可以用小于n的偶数进行排列，小于n的偶数有n/2个，因此我们能够绝对的构造出n/2-1个偶数对，剩下的相邻奇数排列相邻都是互为素数。

​	但是，但k==n/2的时候，所以可以用一个万能的偶数2，去衔接最小的数字6，比如 4 6 8 10 2 6 1 3 5 7 9 。所以要特判 k=n/2 的时候。如果数字小于6，那么就不能构造出k=n/2个。其他情况，根据k来判断就可以了



# A:串

> 长度不超过nnn，且包含子序列“us”的、只由小写字母构成的字符串有多少个？ 答案对109+710^9+7109+7取模。   
>
>    所谓子序列，指一个字符串删除部分字符（也可以不删）得到的字符串。   
>
>    例如，"unoacscc"包含子序列"us"，但"scscucu"则不包含子序列"us"



​	遇到这种问有多少种可能的一般都是dp，和排列组合，此题有两种解法。

## dp

比较基础的dp\[i][0/1/2]，三种不同状态的转移，**因为s是在后面，因此我们只需要讨论在递推过程中是否有添加s，不需要单独讨论s的状态。**

1. 长度为i，并且此串没有u，dp\[i][0]，前面dp\[i-1][0]的串，在末尾加上一个除了u的情况，因此就乘上25
2. 长度为i,并且前面只有有u，由两种转移过来，
3. 长度为i,并且前面有us，由两种状态转移，一种是直接加上s

```
        f[i][0]=(f[i-1][0]*25)%mod;
        f[i][1]=(f[i-1][0]%mod+25*f[i-1][1]%mod)%mod;
        f[i][2]=(f[i-1][1]%mod+f[i-1][2]*26%mod)%mosd;
```



## 容斥思维+递推

​	对于长度为 i 并且有us的字符串设为dp[i]，i+1长度的字符串，对于前面i个字符串里，只有u的字符串=全部可能-没有u的字符串-只有u的字符串，即 dp[i+1]=$26^i$-$25^i$+dp[i]，递推解决即可

![image-20210212163719890](https://img2020.cnblogs.com/blog/2212500/202106/2212500-20210626223023286-1361570129.png)

​	但是其中$26^i$-$25^i$取模的过程之中会出现负数，因此要**( (a%mod-b%mod)+mod ) %mod**





# J一群小青蛙呱蹦呱蹦呱



有n个格子，每个格子里有一个数，1,2,3,4...n   



   牛牛放出**无穷**只青蛙。   

   第一只青蛙的路线是：1->2->4->8->16->....   

   第二只青蛙的路线是：1->3->9->27->81->....   

   第三只青蛙的路线是：1->5->25->125....   

   第四只青蛙的路线是：1->7->49........   

   。。。。。。   

   用数学语言描述，第 ![img](https://www.nowcoder.com/equation?tex=i%5C)只青蛙的路线是首项为1，公比为![img](https://www.nowcoder.com/equation?tex=p(i)%5C)的等比数列，其中![img](https://www.nowcoder.com/equation?tex=p(i)%5C)代表第![img](https://www.nowcoder.com/equation?tex=i%5C)个素数。   

   当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。   

   牛牛想知道，所有**没有被**吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？   

   由于这个lcm可能非常大，请输出它对![img](https://www.nowcoder.com/equation?tex=10%5E9%2B7%5C)取模的值。





## 解析：

1. 留下来的数字的因子**至少要有两个不同的质因子**
2. 每个留下来的数字p，取最小公倍数，如果他们具有相同的素数，就会被最大幂的素数**合并**，因此只要找出质数的$k$次的最大次幂是多少，并且将其相乘即使最终结果。
3. 对于$2^k$，想使得这个$k$最大并且还能保留下来(有两个不同的质因子)，即$2^k*3<=n$, $k$的最大值就是$k=[log_2\frac{n}{3}]$，同理其他质数$x$,要使得指数$k$取得最大，值就应乘上一个2，$x^k*2<=n，$结果是**$k=[log_x\frac{n}{2}]$**。
4. 对于每个质数，k我们可以求得，那么我们就直接累乘出结果即可，幂次方用快速幂处理，素数用线性筛，另外还需要注意的是，素数最大P只需要筛到$\frac{N}{2}$即可，因为最起码都要乘上一个2。如果乘上2就大于p了，那就不合理。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
bool isprime[80000100];//只需要判断到一半就额可以了
int cnt = 0;
vector<int>prime;
int n;

long long qp(ll a, ll b)
{
	long long ans = 1, t = a;
	while (b)
	{
		if (b & 1) ans = ans * t % mod;
		t = t * t %mod;
		b >>= 1;
	}
	return ans;
}
//获取这个质数的最大次幂
ll cal(ll x) {
	if (x == 2) {
		return qp(x, floor(log(n / 3) / log(2)));
	}
	else {
		return qp(x, floor(log(n / 2) / log(x)));
	}
}
int main() {
	cin >> n;
	//筛出素数 对其的最高次幂进行计算，然后乘进答案里面 因为是后面素数是要乘上2，因此这个素数范围就是n/2
	ll ans = 1;
	for (int i = 2; i <= n / 2; i++) {
		if (isprime[i] == 0) {
			prime.push_back(i);
			//对这个i进行计算 乘到答案里面 
			ans =( ans * cal(i)) % mod;
		}
		for (int j = 0; j < prime.size() && (i*prime[j] <= n / 2); j++) {
			isprime[i*prime[j]] = 1;//标记为不是素数
			if (i%prime[j] == 0) {
				break;
			}
		}
	}
	if (ans == 1) {
		cout << "empty";
	}
	else {
		cout << ans;
	}
}
```

