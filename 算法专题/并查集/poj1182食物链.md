# 题目

> 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 
> 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 
> 有人用两种说法对这N个动物所构成的食物链关系进行描述： 
> 第一种说法是"1 X Y"，表示X和Y是同类。 
> 第二种说法是"2 X Y"，表示X吃Y。 
> 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 
> 1）	当前的话与前面的某些真的话冲突，就是假话； 
> 2）	当前的话中X或Y比N大，就是假话； 
> 3）	当前的话表示X吃X，就是假话。 
> 你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数

# 输入输出

> 第一行是两个整数N和K，以一个空格分隔。 
> 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 
> 若D=1，则表示X和Y是同类。 
> 若D=2，则表示X吃Y。
>
> Output
>
> 只有一个整数，表示假话的数目。



# 样例

>Sample Input

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

Sample Output

```
3
```





# 解析

1. 用并查集维护元素之间的关系，并且每个节点维护两个参数

   * 父节点
   * 和父节点的关系

   ```
   struct node {
   	int pr;
   	int la;//根节点和 根节点的关系  0代表同，1代表吃父节点，2代表被父节点吃
   }f[500005];
   ```

   

2. 父节点的关系，我们用0表示相同，1表示吃父节点，2表示被父节点吃。

3. 对于每行数据$X,Y$，我们判断其是否处在**共同的集合**之中，如果处于两个集合，我们只需要将两个集合进行合并即可，因为$X,Y$**没有任何交集**，所以一定是真话。

4. 如果$X,Y$处在**同一个集合**之中，我们只要根据$X,Y$和根节点的关系，我们就能得到$X,Y$的**关系是否正确**，不需要合并了（因为已经在同一个集合，他们之间的关系已经确定）。



## 判断同一个集合之中节点的关系

那么如何确定同一个集合之中的两个节点之间的关系呢？下面用向量简单描述一下。



下图A是根节点，每一个箭头表示向量$$\vec{BA},\vec{AC},\vec{CB}$$，$\vec{BA}$代表BA的关系，值为0，表示BA相同，值为1，表示B吃A,值为2，表示B被A吃，

* 判断是否同类：
  * 只要判断$\vec{BA},\vec{CA}$是否相同即可
* 判断是否B被A吃
  * 我们只要知道，$\vec{BC}$的值即可，根据$\vec{BA}-\vec{CA}=\vec{BC}$，我们就能得到BC的值，加以验证即可。
    * 如图假设c吃a，a吃b，$\vec{AC}=2，\vec{BA}=2$，我们的答案就是 $(\vec{BA}+\vec{AC}+3)\%3=1$，也就是说，b和c的关系是b吃c，因此只需要判断这个值是不是1就可以了
    * 

![image-20210328003401952](C:\Users\37802\AppData\Roaming\Typora\typora-user-images\image-20210328003401952.png)

## 父节点带来的信息

要一直比较



## 路径压缩

我们对于两个数字之间的比较，是通过**根节点为中介**进行比较，但是我们只存储了父节点和父节点的关系，因此我们需要对其进行路径压缩。

![image-20210328005729509](C:\Users\37802\AppData\Roaming\Typora\typora-user-images\image-20210328005729509.png)

首先我们明确一下，在我们路径压缩的时候，**新节点**如何找到**根节点**的呢？是根据**父节点**的父节点就是根节点（压缩后），所以新节点也能找到根节点。（路径压缩的本质）

那么，我们也能根据**父节点**和**根节点**的关系推出**新节点**和**根节点**的关系(取 0或1或2)

但是如何根据父节点推出新节点和根节点的关系呢? 我们用**向量**可以很快的得到结果。

![image-20210328010248025](C:\Users\37802\AppData\Roaming\Typora\typora-user-images\image-20210328010248025.png)

所以根节点和新节点的关系为$\vec{b}=\vec{a}+\vec{c}$，当然在实际的计算过程之中需要进行取模运算，即$(\vec{a}+\vec{c})\%3$

上路径压缩的代码：

```
int find(int i) {
	if (i == f[i].pr) {
		return i;
	}
	//路径压缩
	int t = f[i].pr	;
	f[i].pr = find(f[i].pr);
	f[i].la = (f[t].la + f[i].la) % 3;
	return f[i].pr;
}
```





AC代码：

```
#include<iostream>
using namespace std;
int n, k;
struct node {
	int pr, la;//根节点和 根节点的关系  0代表同，1代表吃父节点，2代表被父节点吃
}f[500005];
void init() {
	for (int i = 1; i < 500005; i++) {
		f[i].pr = i;
		f[i].la = 0;//默认是自身
	}
}

int find(int i) {
	if (i == f[i].pr) {
		return i;
	}
	//路径压缩
	int t = f[i].pr	;
	f[i].pr = find(f[i].pr);
	f[i].la = (f[t].la + f[i].la) % 3;
	return f[i].pr;
}
int main()
{
	scanf("%d%d", &n, &k);
	int ans = 0;
	init();
	for (int i = 1; i <= k; i++) {
		int ope, a, b;
		scanf("%d%d%d", &ope,&a, &b);
		if (a > n || b > n) {
			ans++;	
			continue;
		}
		int fa = find(a), fb = find(b);
		
		if (fa == fb) {//同一个集合 可能会出现问题
			if (ope == 1) {
				if (f[a].la != f[b].la) {
					ans++;
				}
			}
			else {//a吃b
				if ((f[a].la - f[b].la + 3) % 3 != 1) {
					ans++;
				}
			}
		}
		else {//都没出现交集过，直接进行合并即可。
			//a集合进b
			f[fa].pr = fb;
			f[fa].la = ( 3+ f[b].la - f[a].la + (ope-1))%3;//+1表示a吃b  +3避免出现负数
		}
	}
	cout << ans;
	return 0;
}
```

